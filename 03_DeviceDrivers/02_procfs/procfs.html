<html> <body> <table width="100%"> <tbody> <tr> <td bgcolor="#55007F" width="100%" height="50px"> <div align="center"><font color="white" size="+2"><strong> Linux Internals and Programming Essentials<br> Example Programs </strong></font></div> </td> </tr> </table> <p><div align="center"><a href="../additional/index.html">[Back]</a></div></p>
<html> <body> <h1>Proc File System</h1> <p>The <Code>/proc</Code> file system (procfs) is a special file system in the linux kernel. It's a virtual file system: it is not associated with a block device but exists only in memory. The files in the procfs are there to allow userland programs access to certain information from the kernel (like process information in <Code>/proc/[0-9]+/</Code>), and also for debug purposes (like <Code>/proc/ksyms)</Code>. </p> <p> The proc file system has file entries which trigger a read or write function within the kernel when read from or written into. For example Reading from <Code>/proc/devices</Code> will result in a function called <Code>devices_read_proc</Code> being executed. </p> <p> Whenever any file in the <Code>/proc</Code> directory is accessed via read or write system calls; the kernel allocates a page (4096 bytes) of memory. It then passes the address of this page to the corresponding proc read/write functions. These functions read from or write to that page. If a read system call is used, the contents of the page is then sent to the standard output stream. </p> <h2>Proc File Examples</h2> <p>In the following paragraphs we list some proc file entries along with their contents</p> <Code><h3>/proc/cpuinfo</h3></Code> <p>When read it displays some information about the CPU</p> <table bgcolor="#D9DDE5"> <tr> <td width="100%"><pre> processor : 0 vendor_id : AuthenticAMD cpu family : 6 model : 8 model name : AMD Athlon(tm) XP 2000+ stepping : 1 cpu MHz : 1666.732 cache size : 256 KB fdiv_bug : no hlt_bug : no f00f_bug : no coma_bug : no fpu : yes fpu_exception : yes cpuid level : 1 wp : yes flags : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 mmx fxsr sse syscall mmxext 3dnowext 3dnow bogomips : 3322.67 </pre> <td> </tr> </table> <Code><h3>/proc/devices</h3></Code> <p>Lists out registered block and character devices along with their major numbers</p> <table bgcolor="#D9DDE5"> <tr> <td width="100%"><pre> Character devices: 1 mem 2 pty 3 ttyp 4 ttyS 5 cua 6 lp 7 vcs 10 misc 13 input 14 sound 29 fb 36 netlink 128 ptm 129 ptm 130 ptm 131 ptm 132 ptm 133 ptm 134 ptm 135 ptm 136 pts 137 pts 138 pts 139 pts 140 pts 141 pts 142 pts 143 pts 162 raw 180 usb Block devices: 1 ramdisk 2 fd 3 ide0 9 md 12 unnamed 14 unnamed 38 unnamed 39 unnamed </pre> <td> </tr> </table> <Code><h3>/proc/interrupts</h3></Code> <p>Displays hardware interrupt information in many columns</p> <ol> <li>IRQ Number</li> <li>Interrupt Count per CPU</li> <li>Interrupt Controller Hardware</li> <li>Interrupt handler module name</li> </ol> <table bgcolor="#D9DDE5"> <tr> <td width="100%"><pre> CPU0 0: 190380 XT-PIC timer 1: 4747 XT-PIC keyboard 2: 0 XT-PIC cascade 5: 0 XT-PIC usb-uhci, usb-uhci 8: 1 XT-PIC rtc 10: 0 XT-PIC via82cxxx 11: 1117 XT-PIC eth0 12: 68461 XT-PIC PS/2 Mouse 14: 12674 XT-PIC ide0 NMI: 0 ERR: 0 </pre> <td> </tr> </table> <h2>Creating Proc Entries</h2> <p>Proc file entries are created while booting up the system. Every proc entry is registered with the kernel. Proc entries can be created by writing modules. Modules will have to provide read and write functions and register them with the kernel against a proc file entry. Reads and Writes to that file will then be forwarded to the registed read and write functions.</p> <p>Functions used to create proc entries.</p> <pre> #include &lt;linux/proc_fs.h&gt; /104 /banner /bin /boot /CD /dev /etc /fail /home /initrd /ISO /lib /LLC104_CD /LLC106_CD /lost+found /misc /mnt /new /opt /proc /root /sbin /success /tftpboot /tmp /usr /var to create a proc entry in a directory virt/ struct <font color="blue"><a href="../kernel/html/structproc__dir__entry.html">proc_dir_entry</a></font> *<font color="red">create_proc_entry</font>( const char *name, mode_t mode, struct proc_dir_entry *parent ); /104 /banner /bin /boot /CD /dev /etc /fail /home /initrd /ISO /lib /LLC104_CD /LLC106_CD /lost+found /misc /mnt /new /opt /proc /root /sbin /success /tftpboot /tmp /usr /var To remove a proc entry from a directory virt/ void <font color="red">remove_proc_entry</font>( const char *name, struct proc_dir_entry *parent ); /104 /banner /bin /boot /CD /dev /etc /fail /home /initrd /ISO /lib /LLC104_CD /LLC106_CD /lost+found /misc /mnt /new /opt /proc /root /sbin /success /tftpboot /tmp /usr /var To create a new directory in the /proc directory virt/ struct <font color="blue"><a href="../kernel/html/structproc__dir__entry.html">proc_dir_entry</a></font> *<font color="red">proc_mkdir</font>( const char *name, struct proc_dir_entry *parent ); </pre> <p>The name parameter is the name of the file that gets created in the <Code>/proc</Code> directory. The <Code>parent</Code> parameter is the address if the parent directory under which the new proc file is created. If <Code>parent</Code> is null then the entry is created directly under the <Code>/proc </Code>directory.</p> <p>The above functions return a pointer to <Code>proc_dir_entry</Code> structure. To enable read or write operations two function pointers have to be set. They are </p> <pre> struct proc_dir_entry { .... read_proc_t read_proc; write_proc_t write_proc; .... } </pre> <p>Prototypes for read and write functions are as follows</p> <table bgcolor="#F5E5F6"> <tr> <td width="100%"><pre> typedef int (read_proc_t)( char *page, char **start, off_t off, int count, int *eof, void *data ); typedef int (write_proc_t)( struct file *file, const char *buffer, unsigned long count, void *data ); </pre> </td></tr></table> <p> Where: <table> <tr> <td>page</td> <td>information is written into the memory area pointed to by this parameter</td> </tr> <tr> <td>off</td> <td>offset in page from where the information is written</td> </tr> <tr> <td>count</td> <td>The maximum number of bytes that can be written into the page</td> </tr> <tr> <td>eof</td> <td>if set to 1, that means all output was written and if set to 0 means that somemore data has to be written.</td> </tr> <tr> <td>file</td> <td>A pointer to the struct file object which holds session information about the current transaction</td> </tr> </table> </p> <h2>Example Program</h2> <p>For a complete working example refer to <Code>CD/examples/procfs/procfs.c</Code>. The module creates a proc called llc_proc when inserted into the kernel. It returns the jiffies value when read, and writes back a string when written into.</p> <h2>Procfs guide</h2> <p>Click <a href="../kd/procfs-guide/book1.html">here</a> to read a programming guide for procfs</p> <h2>Steps to test the program</h2> <pre> # kgcc procfs.c # insmod procfs.o # cat /proc/llc_proc Hi. my_read. Jiffies 1278222 # echo "Sample" > /proc/llc_proc Got String: Sample </pre> <br><br><p>&nbsp;</p><p>&nbsp;</p>
<table width="100%"> <tr> <td bgcolor="#55007F" width="100%"> <div align="center"><font color="white" size="+2"><strong> Levana Technologies, Mumbai </strong></font></div> </td> </tr> </table> </body></html>
